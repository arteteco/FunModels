install.packages('Hmsc')
# SETUP
library(Hmsc)
library(corrplot)
setwd("~/tesi/FunModels/data/matrix/")
#Lump PA
alldat = read.csv("lump.csv")
head(alldat)
#here you select the columns that contain the environmental variables, which Hmsc calls XData
XData = alldat[,12:17]
head(XData)
# here you select the columns that contain the environmental variables, which Hmsc calls XData
XData <- select(alldat, all_of(toKeep))
library(tidyverse)
# choose the column with the environmental variables
toKeep <- c("N","P","K", "pH", "MaxPrec", "MinTemp")
head(alldat)
# here you select the columns that contain the environmental variables, which Hmsc calls XData
XData <- select(alldat, all_of(toKeep))
head(XData)
#this is the formula we will use to describe the environment
XFormula = ~ N+P+K+pH+MinTemp+MaxPrec
#select these columns for the is the presence-absence matrix of the OMF co-occurrences
Y = alldat[,5:11]
head(Y)
# SETUP
library(Hmsc)
library(corrplot)
library(tidyverse)
setwd("~/tesi/FunModels/data/matrix/")
#Lump PA
alldat = read.csv("lump.csv")
# choose the column with the environmental variables
EnvToKeep <- c("N","P","K", "pH", "MaxPrec", "MinTemp")
PresAbs <- c("cer", "tul", "ino", "ser", "seb", "rus", "the")
# here you select the columns that contain the environmental variables, which Hmsc calls XData
XData <- select(alldat, all_of(EnvToKeep))
head(XData)
#this is the formula we will use to describe the environment
XFormula = ~ N+P+K+pH+MinTemp+MaxPrec
#this is the formula we will use to describe the environment
XFormula = ~ N+P+K+pH+MinTemp+MaxPrec
#select these columns for the is the presence-absence matrix of the OMF co-occurrences
Y = select(alldat, all_of(PresAbs))
studyDesign = data.frame(species = alldat$Orc_species, population = alldat$population)
alldat$population
studyDesign = data.frame(species = alldat$Orc_species, population = alldat$population)
head(studyDesign)
rL_species = HmscRandomLevel(units = studyDesign$species)
rL_population = HmscRandomLevel(units = studyDesign$population)
# this is the basic Hmsc model. We use "probit" regression as we have PA data
m = Hmsc(Y=as.matrix(Y), XData = XData, XFormula = XFormula,
studyDesign = studyDesign, distr = "probit", ranLevels = list(species = rL_species, population = rL_population))
alldat <- drop_na(alldat)
# choose the column with the environmental variables
EnvToKeep <- c("N","P","K", "pH", "MaxPrec", "MinTemp")
PresAbs <- c("cer", "tul", "ino", "ser", "seb", "rus", "the")
# here you select the columns that contain the environmental variables, which Hmsc calls XData
XData <- select(alldat, all_of(EnvToKeep))
#this is the formula we will use to describe the environment
XFormula = ~ N+P+K+pH+MinTemp+MaxPrec
#select these columns for the is the presence-absence matrix of the OMF co-occurrences
Y = select(alldat, all_of(PresAbs))
studyDesign = data.frame(species = alldat$Orc_species, population = alldat$population)
head(studyDesign)
rL_species = HmscRandomLevel(units = studyDesign$species)
rL_population = HmscRandomLevel(units = studyDesign$population)
# this is the basic Hmsc model. We use "probit" regression as we have PA data
m = Hmsc(Y=as.matrix(Y), XData = XData, XFormula = XFormula,
studyDesign = studyDesign, distr = "probit", ranLevels = list(species = rL_species, population = rL_population))
#######settings to run the model i.e. to sample the posterior distribution,
# 3 independent chains each of 250.000 iterations (500 thin * 500 samples) is a good approach
thin = 500
samples = 500
nChains = 3
adaptNf = ceiling(0.4*samples*thin)
transient = ceiling(0.5*samples*thin)
m1 = sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = nChains)
#the model takes a while to run, sometimes a few hours depending on the size of the dataset,
#it is best to save this so you don't have to re-run it
save(m1, file = "Hmsc_Lump_trans0.5sample_thin500_samples250_chains3.RData")
m1 = sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = nChains)
m1 = sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = nChains)
install.packages('snow')
library(snow)
m1 = sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = nChains)
m1 = sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = nChains)
m1 = sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = 6)
cl <- makeCluster(getOption("cl.cores", 2))
m1func <- function(){
sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = nChains)
}
clustercall(fun=m1func,)
clusterCall(fun=m1func,)
clusterCall(cl=cl, fun=m1func)
clusterCall(cl=cl, fun=m1func, library(Hmsc), library(snow))
clusterCall(cl=cl, fun=m1func, library(Hmsc))
clusterCall(cl=cl, library(Hmsc), fun=m1func)
clusterCall(cl=cl, library(Hmsc), fun=m1func)
cl <- makeCluster(6, type="SOCK")
clusterCall(cl=cl, library(Hmsc), fun=m1func)
clusterCall(cl=cl, fun=m1func)
m1func <- function(){
sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = nChains)
}
cl <- makeCluster(detectCores()-1, type="FORK")
cl <- makeCluster(detectCores()-1, type="FORK")
cl <- parallel::makeCluster(detectCores()-1, type="FORK")
# SETUP
library(Hmsc)
library(corrplot)
library(tidyverse)
library(snow)
cl <- parallel::makeCluster(detectCores()-1, type="FORK")
cl <- parallel::makeCluster(parallel::detectCores()-1, type="FORK")
clusterCall(cl=cl, fun=m1func)
cl <- parallel::makeCluster(parallel::detectCores()-1, type="SOCK")
clusterCall(cl=cl, fun=m1func)
cl <- parallel::makeCluster(parallel::detectCores()-1, type="FORK")
clusterCall(cl=cl, fun=m1func)
parallel::clusterCall(cl=cl, fun=m1func)
m1 = sampleMcmc(m, samples = samples, thin = thin,
adaptNf = rep(adaptNf, m$nr), transient = transient,
nChains = nChains, nParallel = nChains)
#examining model fit - important for interpreting model outputs
preds = computePredictedValues(m1)
#examining model fit - important for interpreting model outputs
preds = computePredictedValues(m1)
# the model takes a while to run, sometimes a few hours depending on the size of the dataset,
#it is best to save this so you don't have to re-run it
save(m1, file = "Hmsc_Lump_trans0.5sample_thin500_samples250_chains3.RData")
#examining model fit - important for interpreting model outputs
preds = computePredictedValues(m1)
#examining model fit - important for interpreting model outputs
preds = computePredictedValues(m1)
m1
#examining model fit - important for interpreting model outputs
preds = computePredictedValues(m1)
?computePredictedValues
#examining model fit - important for interpreting model outputs
preds = computePredictedValues(m1, partition=T)
#examining model fit - important for interpreting model outputs
preds = computePredictedValues(m1)
MF = evaluateModelFit(hM = m1, predY = preds)
